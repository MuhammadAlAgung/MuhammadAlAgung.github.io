<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=7ebMze0MJP7bZu91CQ7uEDTuLqYM6x6ICRZT_kL-IXY');ol{margin:0;padding:0}table td,table th{padding:0}.c9{color:#555555;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times";font-style:normal}.c8{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{color:#555555;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times";font-style:normal}.c16{color:#555555;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times";font-style:normal}.c11{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times";font-style:normal}.c5{color:#ff0000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times";font-style:normal}.c2{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times";font-style:normal}.c10{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Times";font-style:normal}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c14{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times";font-style:normal}.c31{color:#555555;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times";font-style:normal}.c24{color:#474747;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Times";font-style:normal}.c27{padding-top:10pt;padding-bottom:4pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c7{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c23{color:#000000;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times";font-style:normal}.c21{padding-top:4pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c22{color:#333333;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times";font-style:normal}.c12{padding-top:24pt;padding-bottom:5pt;line-height:1.15;page-break-after:avoid;text-align:left}.c6{padding-top:24pt;padding-bottom:5pt;line-height:1.15;page-break-after:avoid;text-align:center}.c4{padding-top:0pt;padding-bottom:5pt;line-height:1.15;text-align:left}.c25{padding-top:0pt;padding-bottom:5pt;line-height:1.15;text-align:center}.c17{padding-top:0pt;padding-bottom:5pt;line-height:1.15;text-align:justify}.c19{font-size:18pt;font-family:"Times";font-weight:400}.c30{font-size:14pt;font-family:"Times";font-weight:400}.c29{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{color:inherit;text-decoration:inherit}.c28{height:11pt}.c26{text-indent:36pt}.c18{font-weight:700}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c29"><p class="c6 title" id="h.28jk9qmsj6uo"><span class="c10">Dokumentasi Project Akhir UAS</span></p><p class="c25"><span class="c10">Struktur Data</span></p><p class="c25"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 212.00px; height: 206.72px;"><img alt="" src="image1.png" style="width: 212.00px; height: 206.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c25 c28"><span class="c13"></span></p><p class="c4"><span class="c23 c18">Kelompok</span></p><p class="c4"><span class="c23 c18">Ketua:</span></p><p class="c4"><span class="c15">1. muhammad al agung (171011402314)</span></p><p class="c4"><span class="c18 c23">Anggota:</span></p><p class="c4"><span class="c15">1. paisal arip (171011402345)</span></p><p class="c4"><span class="c30">2. danu mei gustoro (171011401890)</span><hr style="page-break-before:always;display:none;"></p><h1 class="c6" id="h.hu1wcrvg7shu"><span class="c10">Daftar Isi</span></h1><p class="c20"><span class="c13"></span></p><p class="c21"><span class="c18"><a class="c3" href="#h.hu1wcrvg7shu">Daftar Isi</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.hu1wcrvg7shu">2</a></span></p><p class="c7"><span class="c18"><a class="c3" href="#h.9bij3lpatnbz">A. Metode Insertion</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.9bij3lpatnbz">3</a></span></p><p class="c7"><span class="c18"><a class="c3" href="#h.gl720c9j1d3">B. metode selection</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.gl720c9j1d3">7</a></span></p><p class="c7"><span class="c18"><a class="c3" href="#h.ep9jfq7pu8sf">C . Bubble Sort</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.ep9jfq7pu8sf">10</a></span></p><p class="c7"><span class="c18"><a class="c3" href="#h.jbu60nxxl3yb">D. Metode shell</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.jbu60nxxl3yb">12</a></span></p><p class="c7"><span class="c18"><a class="c3" href="#h.xmjiyf4xdfzm">E. Merge Sort</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.xmjiyf4xdfzm">16</a></span></p><p class="c27"><span class="c18"><a class="c3" href="#h.irzh28edf39d">F. METODE QUICK SORT</a></span><span class="c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c18"><a class="c3" href="#h.irzh28edf39d">17</a></span></p><p class="c20"><span class="c13"></span></p><p class="c20"><span class="c13"></span></p><hr style="page-break-before:always;display:none;"><p class="c25 c28"><span class="c13"></span></p><p class="c25 c28"><span class="c13"></span></p><h1 class="c12" id="h.9bij3lpatnbz"><span class="c10">A. Metode Insertion</span></h1><p class="c4"><span class="c0">Berikut adalah contoh algoritma insertion sort jika dituliskan:</span></p><p class="c4"><span class="c0">Insertion_Sort(A)</span></p><p class="c4"><span class="c0">&#9679; Deklarasi Array A</span></p><p class="c4"><span class="c0">&#9679; Deklarasi Elemen</span></p><p class="c4"><span class="c0">&#9679; Input elemen array A</span></p><p class="c4"><span class="c0">&#9679; Input nilai elemen-elemen array A</span></p><p class="c4"><span class="c0">&#9679; For i=1 sampai i &lt; elemen</span></p><p class="c4"><span class="c0">&#9679; While i &gt; 0</span></p><p class="c4"><span class="c0">&#9679; If A[i-1] &gt; A[i]</span></p><p class="c4"><span class="c0">&#9679; Tukar A[i-1] dengan A[i]</span></p><p class="c4"><span class="c0">&#9679; i-1</span></p><p class="c4"><span class="c0">&#9679; end if</span></p><p class="c4"><span class="c0">&#9679; end while</span></p><p class="c4"><span class="c0">&#9679; end for</span></p><p class="c4"><span class="c0">Algoritma di atas bisa digambarkan dalam sebuah flowchart. Fungsi flowchart pada pemrograman adalah untuk memudahkan perancangan sebuah program. Dan berikut ini adalah flowchart dari algoritma insertion sort</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c0">Flowchart lainnya untuk bahan latihan bisa Anda lihat di artikel kami seputar contoh flowchart program.</span></p><p class="c4"><span class="c0">Pada artikel kali ini, kami akan memberikan beberapa contoh algoritma insertion sort. Mari kita simak contoh-contoh berikut ini:</span></p><p class="c4"><span class="c16">&#9679; Contoh 1</span></p><p class="c4"><span class="c0">Langkah 1. Terdapat array dengan 5 elemen seperti di bawah ini:</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c0">Selanjutnya data pada index 0 dan 1 akan dipindahkan ke sorted list. Setelahnya, data pada index 0 dan 1 di sorted list akan dibandingkan untuk mencari index yang memiliki nilai terkecil. Dari data di atas, terlihat bahwa nilai pada index 0 lebih kecil dari nilai index 1. Maka pada sorted list, tidak terjadi perubahan posisi. Hasilnya dapat dilihat pada gambar di bawah ini :</span></p><p class="c4"><span class="c0">Langkah 2. Data pada index 2 dipindahkan ke sorted list. Lalu, data tersebut dibandingkan dengan data-data pada index 0 dan 1. Pada contoh kali ini, hasilnya data pada index 2 memiliki nilai lebih kecil ketimbang data di index 0 dan 1. Hasilnya, data yang baru masuk sortde list tersebut diposisikan ke index 0 dan data-data sebelumnya bergerak mundur. Hasil komparasinya akan seperti gambar berikut:</span></p><p class="c4"><span class="c0">Langkah 3. Data pada index 3 masuk ke sorted list dan dibandingkan dengan data-data yang sudah ada di sorted list. Karena nilai data pada index 3 lebih kecil daripada nilai data di index 0 sampai 2, maka data pada index 3 diposisikan ke index 0 dan data-data lainnya bergerak mundur. Jadinya akan seperti berikut:</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c0">Langkah 4. Langkah terakhir adalah memasukkan data pada index 4 di unsorted list ke dalam sorted list. Setelah dibandingkan, nilai pada data index 4 lebih kecil ketimbang nilai data pada index 1 sampai 3. Hasilnya, data index 4 akan diposisikan ke index 2 dan data setelahnya akan bergerak mundur. Maka, hasilnya akan seperti gambar di bawah ini:</span></p><p class="c4"><span class="c0">Dengan hasil tersebut, maka proses pengurutan dengan metode insertion sort sudah selesai.</span></p><p class="c4"><span class="c16">&#9679; Contoh 2</span></p><p class="c4"><span class="c0">Data awal: [5, 2, 4, 6, 1, 3]. Jumlah index adalah 6, dimulai dari 0 sampai 5. Anggaplah index adalah &ldquo;I&rdquo;, dimana untuk setiap proses pengurutan, perbandingan data akan dimulai dari index kedua (dalam hal ini i=1)</span></p><p class="c4"><span class="c16">Proses I:</span></p><p class="c4"><span class="c0">i=1, x=1; j=0</span></p><p class="c4"><span class="c0">x&lt;j &agrave;2&lt;5? &mdash; true =2, 5, 4, 6, 1, 3</span></p><p class="c4"><span class="c16">Proses II</span></p><p class="c4"><span class="c0">i=2, j=1, x=2</span></p><p class="c4"><span class="c0">x&lt;j &agrave; 4&lt;5 &mdash; true = 2, 4, 5, 6, 1, 3; j=j-1. Artinya jika proses benar, maka &ldquo;x=x-1&rdquo;</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c0">x&lt;j &agrave;4&lt;2 &mdash; false = 2, 4, 5, 6, 1, 3</span></p><p class="c4"><span class="c16">Proses III</span></p><p class="c4"><span class="c0">I=3, j=2, x=3</span></p><p class="c4"><span class="c0">x&lt;j &agrave;6&lt;5 &mdash; false = 2, 4, 5, 6, 1, 3; j=j-1. Artinya jika sebuah proses bernilai false, maka proses tersebut tidak akan dilanjutkan, karena semua data yang ada di sebelah kiri sudah terurut dengan benar secara otomatis .</span></p><p class="c4"><span class="c16">Proses IV</span></p><p class="c4"><span class="c0">i=4, j=3, x=4</span></p><p class="c4"><span class="c0">x&lt;j &agrave;1&lt;6 &mdash; true = 2, 4, 5, 1, 6, 3; j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j &agrave; 1&lt;5 &mdash; true = 2, 4, 1, 5,6, 3; j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j &agrave;1&lt;4 &mdash; true = 2, 1, 4, 5,6, 3; j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j &agrave; 1&lt;2 &mdash; true = 1, 2, 4, 5,6, 3</span></p><p class="c4"><span class="c16">Proses V</span></p><p class="c4"><span class="c0">i=5, j=4, x=5</span></p><p class="c4"><span class="c0">x&lt;j &agrave;3&lt;6 &mdash; true = 1, 2, 4, 5,3, 6 j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j &agrave;3&lt;5 &mdash; true = 1, 2, 4, 3, 5, 6 j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j &agrave;3&lt;4 &mdash; true = 1, 2, 3, 4, 5, 6 j=j-1, jika benar maka x=x-1</span></p><p class="c4"><span class="c0">x&lt;j&agrave;3&lt;2 &mdash; false = 1, 2, 3, 4, 5, 6 j=j-1</span></p><hr style="page-break-before:always;display:none;"><h1 class="c12" id="h.gl720c9j1d3"><span class="c10">B. metode selection</span></h1><p class="c17"><span class="c9">Selection sort yaitu proses memindahkan elemen dengan membandingkan elemen sekarang dengan elemen berikutnya sampai dengan elemen terakhir. Jika ditemukan elemen lain yang lebih kecil dari elemen sekarang maka dicatat posisinya lalu kemudian ditukar dan begitu seterusnya.</span></p><p class="c17"><span class="c9">Pertama program akan mencari data terkecil dari data pertama sampai data yang terakhir, kemudian ditukar posisinya dengan data pertama. Lalu dicari data terkecil dari data kedua sampai dengan data terakhir, kemudian ditukar posisinya dengan data kedua dan seterusnya sampai data terurut naik. Apabila n buah data yang akan diurutkan, maka membutuhkan n-1langkah pengurutan, dengan data terakhir, yaitu data n tidak perlu diurutkan karena hanya tinggal satu-satunya.</span></p><p class="c4"><span class="c18 c31">Pseudocode</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c9">Algoritma_Selection_Sort</span></p><p class="c4"><span class="c9">{Mengurutkan bilangan acak dari bilangan terkecil ke bilangan terbesar dengan metode Selection Sort}</span></p><p class="c4"><span class="c9">Deklarasi</span></p><p class="c4"><span class="c9">i : integer</span></p><p class="c4"><span class="c9">j : integer</span></p><p class="c4"><span class="c9">n : integer</span></p><p class="c4"><span class="c9">min : integer</span></p><p class="c4"><span class="c9">temp : integer</span></p><p class="c4"><span class="c9">A : Array[0...n-1] of integer</span></p><p class="c4"><span class="c9">Deskripsi:</span></p><p class="c4"><span class="c9">Begin</span></p><p class="c4"><span class="c9">for i &larr; 0 to n &ndash; 2 do</span></p><p class="c4"><span class="c9">min &larr; i</span></p><p class="c4"><span class="c9">for j &larr; i + 1 to n &ndash; 1 do</span></p><p class="c4"><span class="c9">if A[j] &lt; A[min]</span></p><p class="c4"><span class="c9">min &larr; j</span></p><p class="c4"><span class="c9">endif</span></p><p class="c4"><span class="c9">endfor</span></p><p class="c4"><span class="c9">swap A[i] and A[min]</span></p><p class="c4"><span class="c9">endfor</span></p><hr style="page-break-before:always;display:none;"><p class="c17"><span class="c9">Algoritma selection sort dalam proses pengurutannya menggunakan metode looping for bertingkat. Seperti biasa yang dipakai adalah variabel i dan j. Sedangkan n merupakan jumlah array yang ada. Dibuat n-1 karena array dimulai dari array ke 0, 1, 2, 3 dst. Untuk min merupakan variabel pembantu dalam proses pertukaran.</span></p><h1 class="c12" id="h.ep9jfq7pu8sf"><span class="c10">C . Bubble Sort</span></h1><p class="c17"><span class="c9">Aplikasi lain dari brute force untuk masalah menyortir adalah Bubble Sort. Cara kerja bubble sort hampir sama dengan Selection Sort. Yang membedakan adalah elemen yang dibandingkan adalah elemen yang berdekatan. Jadi program akan membandingkan elemen pertama dengan kedua, lalu kedua dengan ketiga, lalu ketiga dan keempat dan seterusnya sampai n. Lalu kembali lagi membandingkan elemen pertama dengan kedua, kedua dengan ketiga sampai n-2 (pada iterasi ke-2 elemen terakhir tak dibandingkan lagi).</span></p><hr style="page-break-before:always;display:none;"><p class="c17"><span class="c9">Dengan melakukan hal tersebut berulang-ulang, dapat dipastikan elemen terbesar akan menempati posisi akhir dalam daftar. Berikutnya elemen terbesar kedua akan menempati tempat nomor 2 dari akhir, begitu seterusnya.</span></p><p class="c4"><span class="c31 c18">Pseudocode</span></p><p class="c4"><span class="c9">Algoritma_Bubble_Sort</span></p><p class="c4"><span class="c9">{Mengurutkan bilangan acak dari bilangan terkecil ke bilangan terbesar dengan metode Bubble Sort}</span></p><p class="c4"><span class="c9">Deklarasi:</span></p><p class="c4"><span class="c9">i: integer</span></p><p class="c4"><span class="c9">a : integer</span></p><p class="c4"><span class="c9">j : integer</span></p><p class="c4"><span class="c9">n : integer</span></p><p class="c4"><span class="c9">A: Array [0 . . n-1] of integer</span></p><p class="c4"><span class="c9">Deskripsi:</span></p><p class="c4"><span class="c9">Begin</span></p><p class="c4"><span class="c9">for i &larr; 0 to n&minus;2 do</span></p><p class="c4"><span class="c9">for j &larr; 0 to n&minus;2&minus;i do</span></p><p class="c4"><span class="c9">if A[j +1]&lt;A[j]</span></p><p class="c4"><span class="c9">swap A[j] and A[j +1]</span></p><p class="c4"><span class="c9">endif</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c9">endfor</span></p><p class="c4"><span class="c9">endfor</span></p><p class="c17"><span class="c9">Mirip dengan pseudocode dari selection sort, bubble sort juga menggunakan looping for bertingkat. Dimana bedanya disini yang di tukar (swap) adalah A[j] dan A[j+1] (Array j dan Array j+1) dengan kata lain array yang bersebelahan.</span></p><p class="c17"><span class="c9">Sekian artikel dari Blog Jonarendra yang berjudul Algoritma Selection Sort dan Bubble Sort, semoga dapat menambah wawasan anda tentang algoritma mengurutkan bilangan.</span></p><h1 class="c12" id="h.jbu60nxxl3yb"><span class="c10">D. Metode shell</span></h1><p class="c4"><span class="c1">Shell sort merupakan Metode Pertambahan Menurun yang dikembangkan oleh Donald L. Shell</span></p><p class="c4"><span class="c1">(1959).Metode ini mengurutkan data dengan cara membandingkan suatu data dengan data lain yang memiliki jarak tertentu sehingga</span></p><p class="c4"><span class="c1">dibentuk sub-list, kemudian dilakukan pertukaran jika diperlukan.</span></p><p class="c4"><span class="c1">Jarak yang digunakan disebut increment value, atau sequence number k</span></p><p class="c4"><span class="c1">Misal sekuens: 5,3,1</span></p><p class="c4"><span class="c1">Pengambilan sekuens bebas, asal menurun</span></p><p class="c4"><span class="c1">&bull; Jika k=5, maka sublistnya:</span></p><p class="c4"><span class="c1">&bull; Data[0], Data[5], Data[10], ...</span></p><p class="c4"><span class="c1">&bull; Data[1], Data[6], Data[11], ...</span></p><p class="c4"><span class="c1">&bull; Data[2], Data[7], Data[12], ...</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c1">&bull; Jika k=3, maka sublistnya:</span></p><p class="c4"><span class="c1">&bull; Data[0], Data[3], Data[6], ...</span></p><p class="c4"><span class="c1">&bull; Data[1], Data[4], Data[7], ...</span></p><p class="c4"><span class="c1">&bull; Data[2], Data[5], Data[8], ...</span></p><p class="c4"><span class="c1">Pemilihan Sequence number</span></p><p class="c4"><span class="c1">1. Disarankan jarak mula-mula dari data yang akan dibandingkan adalah (N/2)+1)</span></p><p class="c4"><span class="c1">2. Pada proses berikutnya, digunakan jarak (N/4)+1)</span></p><p class="c4"><span class="c1">3. Pada proses berikutnya, digunakan jarak (N/8)+1)</span></p><p class="c4"><span class="c1">4. Demikian seterusnya sampai jarak yang digunakan adalah 1</span></p><p class="c4"><span class="c1">Proses Pengurutannya</span></p><p class="c4"><span class="c1">1. Untuk jarak (N/2)+1:</span></p><p class="c4 c26"><span class="c1">- Data pertama (i=0) dibandingkan dengan data dengan jarak (N/2)+1. Apabila data pertama lebih besar dari data ke (N/2)+1) tersebut maka kedua data tersebut ditukar.</span></p><p class="c4 c26"><span class="c1">- Kemudian data kedua (i=1) dibandingkan dengan jarak yang sama yaitu (N/2)+1) = elemen ke-(i+N/2)+1</span></p><p class="c4 c26"><span class="c1">- Demikian seterusnya sampai seluruh data dibandingkan sehingga semua data ke-i selalu lebih kecil dari pada data ke-(i+N/2)+1</span></p><p class="c4"><span class="c1">2. Ulangi langakah-langkah diatas untuk jarak = (N/4)+1 kemudian lakukan pembandingan dan pengurutan sehingga semua data ke-i lebih kecil daripada data ke-(i+N/4)+1</span></p><p class="c4"><span class="c1">3. Ulangi langakah-langkah diatas untuk jarak = (N/8)+1 kemudian lakukan pembandingan dan pengurutan sehingga semua data ke-i lebih kecil daripada data ke-(i+N/8)+1</span></p><p class="c4"><span class="c1">4. Demikian seterusnya sampai jarak yang digunakan adalah 1 atau data sudah terurut</span></p><p class="c4"><span class="c1">Contoh:</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c1">Proses pertama, jarak=(N/2)+1=(8/2)+1=5</span></p><p class="c4"><span class="c1">Proses kedua, jarak=(N/4)+1=(8/4)+1=3</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c1">Proses ketiga, jarak=(N/8)=(8/4)=1</span></p><hr style="page-break-before:always;display:none;"><p class="c4 c28"><span class="c1"></span></p><h1 class="c12" id="h.xmjiyf4xdfzm"><span class="c10">E. Merge Sort</span></h1><p class="c4"><span class="c24 c18">Pengertian marge sort</span></p><p class="c17"><span class="c14">Merge sort merupakan salah satu metode dari ke enam metode dalam melakukkan pengurutan atau sorting. Metode ini dinamakan merge sort atau pengurutan secara menggabungkan suatu data. Sesuai dari katanya yaitu merge berarti data akan digabungkan agar menjadi terurut. Bagaimana caranya? Kok dengan menggabungkan data tau-tau udah terurut? Tentu ada teknik dan caranya. Secara garis besar, suatu deret data yang akan diurutkan akan di bagi-bagi terlebih dahulu lalu dibandingkan masing-masing data dari masing-masing bagian lalu baru digabungkan kembali, Untuk lebih lanjut dapat dibaca dibagian metode.</span></p><p class="c17"><span class="c14">Dibandingkan dengan metode sortir yang lain, merge sort merupakan metode yang cukup mudah untuk diikuti dan dipelajari. Jadi diharapkan pembaca mudah untuk mengambil kesimpulan. Dalam kehidupan sehari-hari, contoh penggunaan merge sort biasanya adalah ketika kita mengurutkan suatu benda yang berbeda jenis, bentuk maupun ukuran. Kita biasanya akan membandingkan barang pertama dengan kedua lalu diletakkan untuk kemudian dibandingkan dengan benda ketiga lalu seterusnya. Sedangkan dalam bentuk sequence data, maka cara dan langkah-langkah nya dapat kalian ikuti di bagian metode di bawah ini.</span></p><p class="c4"><span class="c18 c24">Metode</span></p><p class="c17"><span class="c14">Merge sort menggunakan cara memisahkan terlebih dahulu setiap data hingga menjadi berpasangan yang nanti akan dibandingkan untuk kemudian digabungkan kembali. Seperti contohnya, kita memiliki suatu baris data berikut yang akan kita urutkan secara ascending:</span></p><p class="c4"><span class="c11">5 2 3 8 9 4 1 7</span></p><p class="c4"><span class="c14">Dari baris data yang masih acak diatas, kita akan urutkan menurut metode merge sort. Langkah nya adalah sebagai berikut.</span></p><p class="c4"><span class="c14">1. Pertama, dari baris diatas kita bagi menjadi dua bagian. Untuk contoh, terdapat 8 data sehingga jika kita bagi adalah 4 dan 4. Nah kita bagi terlebih dahulu datanya sehingga menjadi berikut</span></p><p class="c4"><span class="c11">5 2 3 8 9 4 1 7</span></p><p class="c4"><span class="c14">2. Setelah kita bagi menjadi dua bagian, masing-masing kita bagi dua kembali. Bagian kanan kita bagi dua, begitu juga bagian kirinya sehingga menjadi berikut</span></p><p class="c4"><span class="c5">5 2 3 8 9 4 1 7</span></p><hr style="page-break-before:always;display:none;"><p class="c17"><span class="c14">3. Nah, berikutnya kita bandingkan masing-masing pasangan untuk kita urutkan secara ascending. Data 5 akan kita bandingkan dengan 2, 3 dibandingkan dengan 8, 9 dibandingkan dengan 4 dan 1 dibandingkan dengan 7.</span></p><p class="c4"><span class="c14">4. Setelah kita bandingkan kita urutkan berdasarkan data terkecil hingga terbesart. Pertama mulai dari bagian kiri.</span></p><p class="c4"><span class="c5">2 5 3 8</span></p><p class="c4"><span class="c14">5. Data bagian kanan sudah diurutkan seperti diatas. Lalu kita urutkan bagian kanan.</span></p><p class="c4"><span class="c15">4 9 1 7</span></p><p class="c4"><span class="c14">6. Data bagian kiri sudah terurut. Sekarang kita akan mulai proses penggabungan atau merge-nya. Mulai dari bagian kiri.</span></p><p class="c4"><span class="c5">2 3 5 8</span></p><p class="c4"><span class="c14">7. Lalu kita urutkan bagian kanan.</span></p><p class="c4"><span class="c15">1 4 7 9</span></p><p class="c4"><span class="c14">8. Sekarang, setiap bagian sudah terurut. Waktunya menggabungkan semuanya hingga menjadi data yang sudah fully sorted.</span></p><p class="c4"><span class="c5">2 3 5 8 1 4 7 9</span></p><p class="c4"><span class="c14">Kita urutkan menjadi</span></p><p class="c4"><span class="c11">1 2 3 4 5 7 8 9</span></p><p class="c4"><span class="c14">9. Data sudah terurut secara ascending atau menaik dengan menggunakan metode merge sort. Mudah bukan?</span></p><p class="c4"><span class="c14">Demikian penjelasan singkat mengenai merge sort dan cara penyelesainnya. Bagi yang masih bingung silakan bertanya dikolom komentar. Terima kasih~</span></p><p class="c4"><span class="c14">Metode yang lain</span></p><hr style="page-break-before:always;display:none;"><h1 class="c12" id="h.irzh28edf39d"><span class="c19">F. </span><span class="c10">METODE QUICK SORT</span></h1><p class="c4"><span class="c8">Algoritma quicksort diperkenalkan pertama kali oleh C.A.R. Hoare pada tahun 1960, dan</span></p><p class="c4"><span class="c8">dimuat sebagai artikel di Computer Journal 5 pada April 1962. Bentuknya yang sederhana, efisien</span></p><p class="c4"><span class="c8">dan efektif dengan cepat membuatnya menjadi algoritma pengurutan (sorting) yang paling banyak</span></p><p class="c4"><span class="c8">digunakan, terutama dalam bahasa pemrograman. Berbagai penelitian dan pengembangan telah</span></p><p class="c4"><span class="c8">banyak dilakukan hingga saat ini. Tercatat peneliti seperti Sedgewick, Bentley, McIlroy, Clement,</span></p><p class="c4"><span class="c8">Flajolet, Vallee, hingga Martinez, membuat analisis dan implementasi dari quicksort.</span></p><p class="c4"><span class="c8">Algoritma quick sort mengurutkan dengan sangat cepat, namun algoritma ini sangat komplex dan</span></p><p class="c4"><span class="c8">diproses secara rekursif.Sangat memungkinkan untuk menulis algoritma yang lebih cepat untuk</span></p><p class="c4"><span class="c8">beberapa kasus khusus, namun untuk kasus umum, sampai saat ini tidak ada yang lebih cepat</span></p><p class="c4"><span class="c8">dibandingkan algoritma quick sort.</span></p><p class="c4"><span class="c8">Quick Sort merupakan suatu algoritma pengurutan data yang menggunakan teknik</span></p><p class="c4"><span class="c8">pemecahan data menjadi partisi-partisi, sehingga metode ini disebut juga dengan nama partition</span></p><p class="c4"><span class="c8">exchange sort. Untuk memulai irterasi pengurutan, pertama-tama sebuah elemen dipilih dari data,</span></p><p class="c4"><span class="c8">kemudian elemen-elemen data akan diurutkan diatur sedemikian rupa Metode Quick sering</span></p><p class="c4"><span class="c8">disebut juga metode partisi (partition exchange sort). Metode ini mempunyai efektifitas yang tinggi</span></p><p class="c4"><span class="c8">dengan teknik menukarkan dua elemen dengan jarak yang cukup besar. Metode pengurutan quick</span></p><p class="c4"><span class="c8">sort dapat diimplementasikan dalam bentuk non rekursif dan rekursif</span></p><p class="c4"><span class="c8">Berbagai varian dari quicksort pada intinya berupaya untuk mengembangkan</span></p><p class="c4"><span class="c8">teknik-teknik pembuatan partisi yang efektif untuk berbagai macam masukan.Hal ini merupakan</span></p><p class="c4"><span class="c8">bahan yang terus dipelajari hingga kini.Ditambah pula dengan perbaikan dari segi pemrograman</span></p><p class="c4"><span class="c8">sehingga lebih efisien (seperti mengurangi operasi pembandingan, pertukaran maupun perulangan).</span></p><p class="c4"><span class="c8">Pada tahun 1998 M.D. McIlroy membuat tulisan berjudul &ldquo;A Killer Adversary for</span></p><p class="c4"><span class="c8">Quicksort&rdquo; yang menguraikan cara untuk membuat susunan data tertentu (dalam array) hingga</span></p><p class="c4"><span class="c8">operasi pengurutan menggunakan quicksort mendekati kuadratik O(n2). Cara ini berlaku untuk</span></p><p class="c4"><span class="c8">setiap varian dari quicksort dengan syarat tertentu.Dikenal juga dengan istilah antiqsort.</span></p><p class="c4"><span class="c22 c18">A. ALGORITMA QUICKSORT</span></p><p class="c4"><span class="c8">1. Divide and Conquer</span></p><p class="c4"><span class="c8">Divide and conquer adalah metode pemecahan masalah yang bekerja dengan membagi</span></p><p class="c4"><span class="c8">(divide) masalah menjadi beberapa sub-masalah yang sama atau berhubungan, hingga masalah</span></p><p class="c4"><span class="c8">tersebut menjadi sederhana untuk dipecahkan (conquer) secara langsung. Pemecahan dari</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c8">tiap-tiap sub-masalah kemudian digabungkan untuk memberikan solusi terhadap masalah</span></p><p class="c4"><span class="c8">semula.</span></p><p class="c4"><span class="c8">Metode divide and conquer menawarkan penyederhanaan masalah dengan pendekatan</span></p><p class="c4"><span class="c8">tiga langkah sederhana: pembagian masalah menjadi sekecil mungkin, penyelesaian</span></p><p class="c4"><span class="c8">masalah-masalah yang telah dikecilkan, kemudian digabungkan kembali untuk mendapat solusi</span></p><p class="c4"><span class="c8">optimal secara keseluruhan. Khusus untuk quicksort, proses penggabungan (combine) tidak perlu</span></p><p class="c4"><span class="c8">dilakukan, karena sudah terjadi secara alami.</span></p><p class="c4"><span class="c8">Dalam penerapannya metode ini dilakukan secara rekursif, yaitu memanggil dirinya</span></p><p class="c4"><span class="c8">sendiri. Cara pemanggilan ini memanfaatkan mekanisme stack dalam menyimpan data yang</span></p><p class="c4"><span class="c8">sedang diproses. Namun bisa juga dengan versi non-rekursif yaitu dengan membuat struktur data</span></p><p class="c4"><span class="c8">tertentu yang meniru cara kerja stack.</span></p><p class="c4"><span class="c8">2. Algoritma</span></p><p class="c4"><span class="c8">Prinsip dalam algoritma quicksort sebagai berikut (diuraikan pula oleh Sedegwick):</span></p><p class="c4"><span class="c8">&middot; Bila elemen dalam array kurang dari jumlah tertentu (biasanya 2), proses selesai.</span></p><p class="c4"><span class="c8">&middot; Ambil sebuah elemen yang berfungsi sebagai poros.</span></p><p class="c4"><span class="c8">&middot; Pisahkan array dalam 2 bagian, sebelah kiri lebih kecil dari poros, sebelah kanan lebih besar</span></p><p class="c4"><span class="c8">dari poros.</span></p><p class="c4"><span class="c8">&middot; Ulangi proses secara rekursif pada tiap-tiap bagian.</span></p><p class="c4"><span class="c8">Hal penting dari hal algoritma ini adalah: bagaimana memilih poros dengan tepat dan secara</span></p><p class="c4"><span class="c8">efisien mengatur tiap-tiap elemen sehingga didapat elemen kecil &gt; poros &gt; elemen besar dalam</span></p><p class="c4"><span class="c8">kondisi (mendekati) seimbang.</span></p><p class="c4"><span class="c8">3. Kompleksitas</span></p><p class="c4"><span class="c8">Kebutuhan waktu dari quicksort bergantung pada pembuatan partisi, seimbang atau</span></p><p class="c4"><span class="c8">tidak, yang bergantung juga pada elemen yang digunakan sebagai poros.Dalam menghitung</span></p><p class="c4"><span class="c8">kompleksitas ini, perlu dilihat pula perhitungan recurrence, karena terdapat fungsi rekursif untuk</span></p><p class="c4"><span class="c8">penyelesaian sub-masalah.</span></p><p class="c4"><span class="c22 c18">B. PROGRAM PENDUKUNG</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c8">Untuk membantu pengujian dibuatlah sebuah program khusus[7]. Baik program maupun</span></p><p class="c4"><span class="c8">penerapan algoritma quicksort menggunakan bahasa Object Pascal, khususnya menggunakan</span></p><p class="c4"><span class="c8">Borland Delphi.Bahasa Pascal mudah dimengerti dan cukup mewakili dalam penulisan algoritma.</span></p><p class="c4"><span class="c8">1. Class TQuickSort</span></p><p class="c4"><span class="c8">Untuk menyeragamkan penulisan tiap-tiap algoritma, dibuat sebuah common class, yaitu</span></p><p class="c4"><span class="c8">TQuickSort.Class ini berisi fungsi-fungsi yang ada dalam tiap-tiap algoritma quicksort dan</span></p><p class="c4"><span class="c8">melakukan pencatatan statistik tiap kali dipanggil. Berikut isi rutin-rutin tersebut:</span></p><p class="c4"><span class="c2">&middot; Compare (X, Y), yaitu membandingkan X dan Y dengan hasil negatif bila</span></p><p class="c4"><span class="c2">lebih kecil, 0 bila sama, dan positif bila lebih besar.</span></p><p class="c4"><span class="c2">&middot; Exchange (X, Y), yaitu menukar variabel pada posisi X dan Y.</span></p><p class="c4"><span class="c2">&middot; CheckStack, yaitu mengecek banyaknya pemanggilan diri sendiri (rekursif)</span></p><p class="c4"><span class="c2">yang dilakukan. Pengecekan ini dengan melihat posisi stack (ESP), apabila</span></p><p class="c4"><span class="c2">berbeda dari posisi sebelumnya maka kedalaman rekursif telah bertambah.</span></p><p class="c4"><span class="c2">&middot; Sort, yaitu fungsi publik yang melakukan operasi pengurutan. Sebelumnya</span></p><p class="c4"><span class="c2">array masukan disalin ke buffer internal, memanggil fungsi quicksort, dan</span></p><p class="c4"><span class="c2">mengecek hasil apakah telah urut. Keluaran dari fungsi ini berupa string</span></p><p class="c4"><span class="c2">statistik hasil.</span></p><p class="c4"><span class="c2">&middot; AntiSort, yaitu fungsi publik untuk mengisi array dengan susunan angka</span></p><p class="c4"><span class="c2">sesuai algoritma antiqsort. Hasil array ini akan diurutkan kembali tahap</span></p><p class="c4"><span class="c2">berikutnya.</span></p><p class="c4"><span class="c8">Setiap implementasi algoritma quicksort diturunkan dari class TQuickSort, dengan</span></p><p class="c4"><span class="c8">mendefinisikan ulang (override) prosedur abstrak quicksort. Ketika dijalankan (fungsi Sort),</span></p><p class="c4"><span class="c8">setiap algoritma yang didaftarkan akan dipanggil dan hasilnya ditampilkan dalam TMemo.</span></p><p class="c4"><span class="c18 c22">C. PERCOBAAN DAN ANALISA</span></p><p class="c4"><span class="c8">Menggunakan class TQuickSort, yang diturunkan dalam bermacam-macam algoritma,</span></p><p class="c4"><span class="c8">dilakukan pengujian unjuk kerja. Hal-hal yang dipantau adalah:</span></p><p class="c4"><span class="c2">&middot; Pembandingan, yaitu berapa banyak terjadi pembandingan antara 2 elemen.</span></p><p class="c4"><span class="c2">Setiap operasi pembandingan, baik dalam mencari elemen ataupun poros, akan</span></p><p class="c4"><span class="c2">dicatat.</span></p><p class="c4"><span class="c2">&middot; Penukaran, yaitu berapa banyak terjadi pertukaran antara 2 elemen.</span></p><p class="c4"><span class="c2">&middot; Rekursif, yaitu berapa dalam terjadi pemanggilan stack (dalam proses rekursif).</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c2">&middot; Waktu, yaitu berapa lama (dalam milidetik) suatu algoritma berjalan. Waktu</span></p><p class="c4"><span class="c2">yang dibutuhkan suatu algoritma tidak selalu berbanding lurus dengan operasi</span></p><p class="c4"><span class="c2">pembandingan, pertukaran, maupun rekursif.</span></p><p class="c4"><span class="c8">Akibat pengembangan quicksort sudah sedemikian rupa, sehingga asal-usul dan bentuk</span></p><p class="c4"><span class="c8">algoritma tidak diketahui asalnya.Dalam hal ini hanya diambil beberapa contoh quicksort yang</span></p><p class="c4"><span class="c8">dianggap cukup mewakili sebagai percobaan.</span></p><p class="c4"><span class="c8">Dalam melakukan pengambilan waktu tidak dilakukan hasil rata-rata, melainkan pada 1x</span></p><p class="c4"><span class="c8">hasil saja. Hal ini disebabkan pengambilan contoh (sampling) array sudah cukup mewakili, yaitu</span></p><p class="c4"><span class="c8">1.000.000 angka Integer (4 byte), kecuali 10.000 angka untuk algoritma (partisi) Lomuto dan</span></p><p class="c4"><span class="c8">antiqsort.</span></p><p class="c4"><span class="c2">v Beberapa hal yang membuat quicksort unggul:</span></p><p class="c4"><span class="c2">&middot; Secara umum memiliki kompleksitas O(n log n).</span></p><p class="c4"><span class="c2">&middot; Algoritmanya sederhana dan mudah diterapkan pada berbagai bahasa</span></p><p class="c4"><span class="c2">pemrograman dan arsitektur mesin secara efisien.</span></p><p class="c4"><span class="c2">&middot; Dalam prakteknya adalah yang tercepat dari berbagai algoritma pengurutan</span></p><p class="c4"><span class="c2">dengan perbandingan, seperti mergesort dan heapsort.</span></p><p class="c4"><span class="c2">&middot; Melakukan proses langsung pada input (in-place) dengan sedikit tambahan</span></p><p class="c4"><span class="c2">memori.</span></p><p class="c4"><span class="c2">&middot; Bekerja dengan baik pada berbagai jenis input data (seperti angka dan</span></p><p class="c4"><span class="c2">karakter).</span></p><p class="c4"><span class="c2">v Namun terdapat pula kelemahan quicksort:</span></p><p class="c4"><span class="c2">&middot; Sedikit kesalahan dalam penulisan program membuatnya bekerja tidak</span></p><p class="c4"><span class="c2">beraturan (hasilnya tidak benar atau tidak pernah selesai).</span></p><p class="c4"><span class="c2">&middot; Memiliki ketergantungan terhadap data yang dimasukkan, yang dalam kasus</span></p><p class="c4"><span class="c2">terburuk memiliki kompleksitas O(n2).</span></p><p class="c4"><span class="c2">&middot; Secara umum bersifat tidak stable, yaitu mengubah urutan input dalam hasil</span></p><p class="c4"><span class="c2">akhirnya (dalam hal inputnya bernilai sama).</span></p><p class="c4"><span class="c2">&middot; Pada penerapan secara rekursif (memanggil dirinya sendiri) bila terjadi kasus</span></p><p class="c4"><span class="c2">terburuk dapat menghabiskan stack dan memacetkan program.</span></p><hr style="page-break-before:always;display:none;"><p class="c4"><span class="c2">&middot; Pada bahasa pemrograman, quicksort ada dalam pustaka stdlib.h untuk bahasa</span></p><p class="c4"><span class="c2">C, dan class TList dan TStringList dalam Delphi (Object Pascal) maupun</span></p><p class="c4"><span class="c2">FreePascal.</span></p><p class="c4"><span class="c8">Contoh Quick Sort:</span></p></body></html>
